<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>js on Paran.Blue</title>
    <link>https://bynaki.github.io/tags/js/</link>
    <description>Recent content in js on Paran.Blue</description>
    <image>
      <url>https://bynaki.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://bynaki.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 13 Nov 2021 00:12:53 +0900</lastBuildDate><atom:link href="https://bynaki.github.io/tags/js/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Js.optional</title>
      <link>https://bynaki.github.io/posts/js.optional.chaining/</link>
      <pubDate>Sat, 13 Nov 2021 00:12:53 +0900</pubDate>
      
      <guid>https://bynaki.github.io/posts/js.optional.chaining/</guid>
      <description>Optional chaining (?. 연산자) optional chaining 연산자 (?.) 는 체인의 각 참조가 유효한지 명시적으로 검증하지 않고, 연결된 객체 체인 내에 깊숙이 위치한 속성 값을 읽을 수 있다.
?. 연산자는 . 체이닝 연산자와 유사하게 작동하지만, 만약 참조가 nullish (en-US) (null 또는 undefined)이라면, 에러가 발생하는 것 대신에 표현식의 리턴 값은 undefined로 단락된다. 함수 호출에서 사용될 때, 만약 주어진 함수가 존재하지 않는다면, undefined를 리턴한다.
따라서 참조가 누락될 가능성이 있는 경우 연결된 속성으로 접근할 때 더 짧고 간단한 표현식이 생성된다.</description>
    </item>
    
    <item>
      <title>Js :: JsDoc</title>
      <link>https://bynaki.github.io/posts/js.jsdoc/</link>
      <pubDate>Mon, 23 Aug 2021 20:28:29 +0900</pubDate>
      
      <guid>https://bynaki.github.io/posts/js.jsdoc/</guid>
      <description>JSDoc이란? JSDoc은 Javadoc과 유사한 JavaScript용 API 문서 생성기이다. 문서 주석을 코드와 함께 소스 코드에 직접 추가할 수 있다. JSDoc은 소스 코드를 스캔하고 HTML 문서를 생성한다.
JSDoc의 주목적은 JavaScript 앱 또는 라이브러리 API를 문서화하는 것이다. 모듈, 네임스페이스, 클래스, 메서드, 파라미터 등과 같은 항목을 문서화할 것으로 가정한다.
일반적으로 JSDoc 주석은 코드가 문서화되기 직전에 배치되어야 한다. 각 주석은 /** 시퀀스로 시작해야 JSDoc 파서가 인식할 수 있다. /*, /*** 으로 시작되는 설명은 무시된다.
JSDoc을 사용해서 무엇을 할 수 있을까?</description>
    </item>
    
    <item>
      <title>Js :: async/await Catch Error</title>
      <link>https://bynaki.github.io/posts/js.async-await-catch-error/</link>
      <pubDate>Mon, 16 Aug 2021 19:58:31 +0900</pubDate>
      
      <guid>https://bynaki.github.io/posts/js.async-await-catch-error/</guid>
      <description>async function을 바로 return하면 error를 catch 하지 못한다.
let count = 0 function asyncFunc() { return new Promise((resolve, reject) =&amp;gt; { if(count % 10 === 0) { count++ reject(new Error(&amp;#39;error!!&amp;#39;)) return } resolve(++count) }) } async function bad() { try { // await 하지 않고 바로 리턴하면 에러를 캣치하지 못한다.  return asyncFunc() } catch(e) { console.log(e.message) return asyncFunc() } } async function right() { try { const res = await asyncFunc() return res } catch(e) { console.</description>
    </item>
    
    <item>
      <title>Js :: for wait...of</title>
      <link>https://bynaki.github.io/posts/js.for-wait-of/</link>
      <pubDate>Mon, 09 Aug 2021 18:36:53 +0900</pubDate>
      
      <guid>https://bynaki.github.io/posts/js.for-wait-of/</guid>
      <description>for await&amp;hellip;of for await...of 구문은 보통 비동기에 대응하는 열거자를 나열할 때 쓰이지만, String, Array, Array 같은 객체 (e.g., arguments or NodeList), TypedArray, Map, Set 같은 동기적으로 열거 가능한 객체 또한 가능하며, 사용자가 직접 정의한 동기 또는 비동기 객체도 나열할 수 있도록 해준다. 일반적인 for ...of 문과 마찬가지로 열거자 심볼이 정의한 속성을 실행하게 되어 열거한 값을 변수로 받아 처리한다.
구문 for await (variable of iterable) { statement }   variable</description>
    </item>
    
    <item>
      <title>Js :: Promise.all()</title>
      <link>https://bynaki.github.io/posts/js.promise-all/</link>
      <pubDate>Sun, 08 Aug 2021 12:54:59 +0900</pubDate>
      
      <guid>https://bynaki.github.io/posts/js.promise-all/</guid>
      <description>Promise.all() source:
const times = [2000, 500, 3000, 1000] await Promise.all(times.map(async t =&amp;gt; { await stop(t) console.log(t) })) output:
500 1000 2000 3000 </description>
    </item>
    
    <item>
      <title>Js :: Generator</title>
      <link>https://bynaki.github.io/posts/js.generator/</link>
      <pubDate>Mon, 26 Jul 2021 01:18:06 +0900</pubDate>
      
      <guid>https://bynaki.github.io/posts/js.generator/</guid>
      <description>Generator **Generator** 객체는 generator function 으로부터 반환된 값이며 반복자와 반복자 프로토콜을 준수합니다.
문법 function* gen() { yield 1; yield 2; yield 3; } var g = gen(); // &amp;#34;Generator { }&amp;#34; 메서드   Generator.prototype.next()
yield 표현을 통해 yield된 값을 반환합니다.
  Generator.prototype.return()
주어진 값을 반환하고 생성기를 종료합니다.
  Generator.prototype.throw()
생성기로 에러를 throw합니다.
  예시 무한 반복자 function* idMaker(){ var index = 0; while(true) yield index++; } var gen = idMaker(); // &amp;#34;Generator { }&amp;#34;  console.</description>
    </item>
    
  </channel>
</rss>
